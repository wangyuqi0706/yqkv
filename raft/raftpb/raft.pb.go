// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft/raftpb/raft.proto

package raftpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AppendEntriesStatus int32

const (
	Success     AppendEntriesStatus = 0
	OldTerm     AppendEntriesStatus = 1
	NotContain  AppendEntriesStatus = 2
	OldSnapshot AppendEntriesStatus = 3
)

var AppendEntriesStatus_name = map[int32]string{
	0: "Success",
	1: "OldTerm",
	2: "NotContain",
	3: "OldSnapshot",
}

var AppendEntriesStatus_value = map[string]int32{
	"Success":     0,
	"OldTerm":     1,
	"NotContain":  2,
	"OldSnapshot": 3,
}

func (x AppendEntriesStatus) String() string {
	return proto.EnumName(AppendEntriesStatus_name, int32(x))
}

func (AppendEntriesStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{0}
}

type Args struct {
	Term   uint64 `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Leader uint64 `protobuf:"varint,2,opt,name=Leader,proto3" json:"Leader,omitempty"`
}

func (m *Args) Reset()         { *m = Args{} }
func (m *Args) String() string { return proto.CompactTextString(m) }
func (*Args) ProtoMessage()    {}
func (*Args) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{0}
}
func (m *Args) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Args) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Args.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Args) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Args.Merge(m, src)
}
func (m *Args) XXX_Size() int {
	return m.Size()
}
func (m *Args) XXX_DiscardUnknown() {
	xxx_messageInfo_Args.DiscardUnknown(m)
}

var xxx_messageInfo_Args proto.InternalMessageInfo

type Entry struct {
	Term  uint64 `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Index uint64 `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	Data  []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{1}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

type AppendEntriesArgs struct {
	Args         *Args    `protobuf:"bytes,1,opt,name=args,proto3" json:"args,omitempty"`
	Entries      []*Entry `protobuf:"bytes,2,rep,name=Entries,proto3" json:"Entries,omitempty"`
	CommitTerm   uint64   `protobuf:"varint,3,opt,name=CommitTerm,proto3" json:"CommitTerm,omitempty"`
	LeaderCommit uint64   `protobuf:"varint,4,opt,name=LeaderCommit,proto3" json:"LeaderCommit,omitempty"`
	PrevLogIndex uint64   `protobuf:"varint,6,opt,name=PrevLogIndex,proto3" json:"PrevLogIndex,omitempty"`
	PrevLogTerm  uint64   `protobuf:"varint,7,opt,name=PrevLogTerm,proto3" json:"PrevLogTerm,omitempty"`
}

func (m *AppendEntriesArgs) Reset()         { *m = AppendEntriesArgs{} }
func (m *AppendEntriesArgs) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesArgs) ProtoMessage()    {}
func (*AppendEntriesArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{2}
}
func (m *AppendEntriesArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntriesArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesArgs.Merge(m, src)
}
func (m *AppendEntriesArgs) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesArgs.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesArgs proto.InternalMessageInfo

type AppendEntriesReply struct {
	Term   uint64              `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Status AppendEntriesStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=raftpb.AppendEntriesStatus" json:"Status,omitempty"`
	XIndex uint64              `protobuf:"varint,3,opt,name=XIndex,proto3" json:"XIndex,omitempty"`
	XLen   uint64              `protobuf:"varint,4,opt,name=XLen,proto3" json:"XLen,omitempty"`
	XTerm  uint64              `protobuf:"varint,5,opt,name=XTerm,proto3" json:"XTerm,omitempty"`
}

func (m *AppendEntriesReply) Reset()         { *m = AppendEntriesReply{} }
func (m *AppendEntriesReply) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesReply) ProtoMessage()    {}
func (*AppendEntriesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{3}
}
func (m *AppendEntriesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntriesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesReply.Merge(m, src)
}
func (m *AppendEntriesReply) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesReply proto.InternalMessageInfo

type InstallSnapshotArgs struct {
	Args     *Args     `protobuf:"bytes,1,opt,name=Args,proto3" json:"Args,omitempty"`
	Snapshot *Snapshot `protobuf:"bytes,2,opt,name=Snapshot,proto3" json:"Snapshot,omitempty"`
}

func (m *InstallSnapshotArgs) Reset()         { *m = InstallSnapshotArgs{} }
func (m *InstallSnapshotArgs) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotArgs) ProtoMessage()    {}
func (*InstallSnapshotArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{4}
}
func (m *InstallSnapshotArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallSnapshotArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotArgs.Merge(m, src)
}
func (m *InstallSnapshotArgs) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotArgs.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotArgs proto.InternalMessageInfo

type InstallSnapshotReply struct {
	Term uint64 `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
}

func (m *InstallSnapshotReply) Reset()         { *m = InstallSnapshotReply{} }
func (m *InstallSnapshotReply) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotReply) ProtoMessage()    {}
func (*InstallSnapshotReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{5}
}
func (m *InstallSnapshotReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallSnapshotReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotReply.Merge(m, src)
}
func (m *InstallSnapshotReply) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotReply.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotReply proto.InternalMessageInfo

type RequestVoteArgs struct {
	Args         *Args  `protobuf:"bytes,1,opt,name=args,proto3" json:"args,omitempty"`
	CandidateID  uint64 `protobuf:"varint,2,opt,name=CandidateID,proto3" json:"CandidateID,omitempty"`
	LastLogIndex uint64 `protobuf:"varint,3,opt,name=LastLogIndex,proto3" json:"LastLogIndex,omitempty"`
	LastLogTerm  uint64 `protobuf:"varint,4,opt,name=LastLogTerm,proto3" json:"LastLogTerm,omitempty"`
}

func (m *RequestVoteArgs) Reset()         { *m = RequestVoteArgs{} }
func (m *RequestVoteArgs) String() string { return proto.CompactTextString(m) }
func (*RequestVoteArgs) ProtoMessage()    {}
func (*RequestVoteArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{6}
}
func (m *RequestVoteArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVoteArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteArgs.Merge(m, src)
}
func (m *RequestVoteArgs) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteArgs.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteArgs proto.InternalMessageInfo

type RequestVoteReply struct {
	Term        uint64 `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	VoteGranted bool   `protobuf:"varint,2,opt,name=VoteGranted,proto3" json:"VoteGranted,omitempty"`
}

func (m *RequestVoteReply) Reset()         { *m = RequestVoteReply{} }
func (m *RequestVoteReply) String() string { return proto.CompactTextString(m) }
func (*RequestVoteReply) ProtoMessage()    {}
func (*RequestVoteReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{7}
}
func (m *RequestVoteReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVoteReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteReply.Merge(m, src)
}
func (m *RequestVoteReply) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteReply.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteReply proto.InternalMessageInfo

type Snapshot struct {
	Metadata *SnapshotMetaData `protobuf:"bytes,1,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Data     []byte            `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{8}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

type SnapshotMetaData struct {
	Index uint64 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	Term  uint64 `protobuf:"varint,2,opt,name=Term,proto3" json:"Term,omitempty"`
}

func (m *SnapshotMetaData) Reset()         { *m = SnapshotMetaData{} }
func (m *SnapshotMetaData) String() string { return proto.CompactTextString(m) }
func (*SnapshotMetaData) ProtoMessage()    {}
func (*SnapshotMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{9}
}
func (m *SnapshotMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotMetaData.Merge(m, src)
}
func (m *SnapshotMetaData) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotMetaData proto.InternalMessageInfo

type HardState struct {
	Term     uint64 `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	VotedFor uint64 `protobuf:"varint,2,opt,name=VotedFor,proto3" json:"VotedFor,omitempty"`
	Commit   uint64 `protobuf:"varint,3,opt,name=Commit,proto3" json:"Commit,omitempty"`
}

func (m *HardState) Reset()         { *m = HardState{} }
func (m *HardState) String() string { return proto.CompactTextString(m) }
func (*HardState) ProtoMessage()    {}
func (*HardState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{10}
}
func (m *HardState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardState.Merge(m, src)
}
func (m *HardState) XXX_Size() int {
	return m.Size()
}
func (m *HardState) XXX_DiscardUnknown() {
	xxx_messageInfo_HardState.DiscardUnknown(m)
}

var xxx_messageInfo_HardState proto.InternalMessageInfo

type Log struct {
	Entries       []*Entry `protobuf:"bytes,1,rep,name=Entries,proto3" json:"Entries,omitempty"`
	IncludedIndex uint64   `protobuf:"varint,2,opt,name=IncludedIndex,proto3" json:"IncludedIndex,omitempty"`
	IncludedTerm  uint64   `protobuf:"varint,3,opt,name=IncludedTerm,proto3" json:"IncludedTerm,omitempty"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{11}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

type RaftState struct {
	HardState *HardState `protobuf:"bytes,1,opt,name=HardState,proto3" json:"HardState,omitempty"`
	Log       *Log       `protobuf:"bytes,2,opt,name=Log,proto3" json:"Log,omitempty"`
}

func (m *RaftState) Reset()         { *m = RaftState{} }
func (m *RaftState) String() string { return proto.CompactTextString(m) }
func (*RaftState) ProtoMessage()    {}
func (*RaftState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{12}
}
func (m *RaftState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftState.Merge(m, src)
}
func (m *RaftState) XXX_Size() int {
	return m.Size()
}
func (m *RaftState) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftState.DiscardUnknown(m)
}

var xxx_messageInfo_RaftState proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("raftpb.AppendEntriesStatus", AppendEntriesStatus_name, AppendEntriesStatus_value)
	proto.RegisterType((*Args)(nil), "raftpb.Args")
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
	proto.RegisterType((*AppendEntriesArgs)(nil), "raftpb.AppendEntriesArgs")
	proto.RegisterType((*AppendEntriesReply)(nil), "raftpb.AppendEntriesReply")
	proto.RegisterType((*InstallSnapshotArgs)(nil), "raftpb.InstallSnapshotArgs")
	proto.RegisterType((*InstallSnapshotReply)(nil), "raftpb.InstallSnapshotReply")
	proto.RegisterType((*RequestVoteArgs)(nil), "raftpb.RequestVoteArgs")
	proto.RegisterType((*RequestVoteReply)(nil), "raftpb.RequestVoteReply")
	proto.RegisterType((*Snapshot)(nil), "raftpb.Snapshot")
	proto.RegisterType((*SnapshotMetaData)(nil), "raftpb.SnapshotMetaData")
	proto.RegisterType((*HardState)(nil), "raftpb.HardState")
	proto.RegisterType((*Log)(nil), "raftpb.Log")
	proto.RegisterType((*RaftState)(nil), "raftpb.RaftState")
}

func init() { proto.RegisterFile("raft/raftpb/raft.proto", fileDescriptor_1e9d4c87982c6a6a) }

var fileDescriptor_1e9d4c87982c6a6a = []byte{
	// 782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4f, 0x6f, 0xda, 0x48,
	0x14, 0xc7, 0x40, 0x80, 0x3c, 0xe7, 0x0f, 0x99, 0x44, 0x59, 0x96, 0xdd, 0xb5, 0x90, 0xb5, 0xd2,
	0xa2, 0x68, 0x0b, 0x11, 0xa9, 0xda, 0x4b, 0x0f, 0x4d, 0x49, 0xd2, 0x20, 0xd1, 0x24, 0x32, 0x51,
	0x15, 0xb5, 0xa7, 0x01, 0x4f, 0x1c, 0x54, 0xb0, 0x89, 0x3d, 0xa4, 0xc9, 0xb7, 0xe8, 0xb1, 0x52,
	0x0f, 0xfd, 0x3a, 0x39, 0xe6, 0xd8, 0x63, 0x13, 0x2e, 0xfd, 0x18, 0xd5, 0xbc, 0xb1, 0x9d, 0x01,
	0x99, 0xaa, 0x17, 0x98, 0xf7, 0x7b, 0xbf, 0x99, 0x79, 0xff, 0x7e, 0x63, 0xd8, 0xf4, 0xe9, 0x39,
	0xaf, 0x8b, 0x9f, 0x51, 0x17, 0xff, 0x6a, 0x23, 0xdf, 0xe3, 0x1e, 0xc9, 0x49, 0xa8, 0xfc, 0xc4,
	0xe9, 0xf3, 0x8b, 0x71, 0xb7, 0xd6, 0xf3, 0x86, 0x75, 0xc7, 0x73, 0xbc, 0x3a, 0xba, 0xbb, 0xe3,
	0x73, 0xb4, 0xd0, 0xc0, 0x95, 0xdc, 0x66, 0x36, 0x20, 0xbb, 0xeb, 0x3b, 0x01, 0x21, 0x90, 0x3d,
	0x65, 0xfe, 0xb0, 0xa4, 0x55, 0xb4, 0x6a, 0xd6, 0xc2, 0x35, 0xd9, 0x84, 0x5c, 0x9b, 0x51, 0x9b,
	0xf9, 0xa5, 0x34, 0xa2, 0xa1, 0x65, 0xee, 0xc3, 0xc2, 0xbe, 0xcb, 0xfd, 0x9b, 0xc4, 0x4d, 0x1b,
	0xb0, 0xd0, 0x72, 0x6d, 0x76, 0x1d, 0xee, 0x91, 0x86, 0x60, 0xee, 0x51, 0x4e, 0x4b, 0x99, 0x8a,
	0x56, 0x5d, 0xb2, 0x70, 0x6d, 0xfe, 0xd0, 0x60, 0x6d, 0x77, 0x34, 0x62, 0xae, 0x2d, 0x4e, 0xeb,
	0xb3, 0x00, 0x03, 0xa9, 0x40, 0x96, 0xfa, 0x4e, 0x80, 0x67, 0xea, 0x8d, 0xa5, 0x9a, 0x4c, 0xab,
	0x26, 0x7c, 0x16, 0x7a, 0xc8, 0x7f, 0x90, 0x0f, 0x37, 0x94, 0xd2, 0x95, 0x4c, 0x55, 0x6f, 0x2c,
	0x47, 0x24, 0x8c, 0xca, 0x8a, 0xbc, 0xc4, 0x00, 0x68, 0x7a, 0xc3, 0x61, 0x9f, 0x63, 0x90, 0x19,
	0x8c, 0x47, 0x41, 0x88, 0x09, 0x4b, 0x32, 0x23, 0x89, 0x95, 0xb2, 0xc8, 0x98, 0xc2, 0x04, 0xe7,
	0xc4, 0x67, 0x57, 0x6d, 0xcf, 0x91, 0x59, 0xe5, 0x24, 0x47, 0xc5, 0x48, 0x05, 0xf4, 0xd0, 0xc6,
	0x8b, 0xf2, 0x48, 0x51, 0x21, 0xf3, 0xab, 0x06, 0x64, 0x2a, 0x55, 0x8b, 0x8d, 0x06, 0xc9, 0xf5,
	0xdb, 0x81, 0x5c, 0x87, 0x53, 0x3e, 0x0e, 0xb0, 0x80, 0x2b, 0x8d, 0xbf, 0xe2, 0x0a, 0xa8, 0xfb,
	0x25, 0xc5, 0x0a, 0xa9, 0xa2, 0x53, 0x67, 0x32, 0x3e, 0x99, 0x65, 0x68, 0x89, 0x0b, 0xce, 0xda,
	0xcc, 0x0d, 0x33, 0xc3, 0xb5, 0x68, 0xd0, 0x19, 0xde, 0xba, 0x20, 0x1b, 0x84, 0x86, 0xc9, 0x60,
	0xbd, 0xe5, 0x06, 0x9c, 0x0e, 0x06, 0x1d, 0x97, 0x8e, 0x82, 0x0b, 0x8f, 0x47, 0xdd, 0xd8, 0x9d,
	0xdb, 0x0d, 0x64, 0xfc, 0x0f, 0x85, 0x68, 0x07, 0x46, 0xac, 0x37, 0x8a, 0x11, 0x2b, 0xc2, 0xad,
	0x98, 0x61, 0x6e, 0xc1, 0xc6, 0xcc, 0x35, 0x73, 0x2b, 0x61, 0x7e, 0xd1, 0x60, 0xd5, 0x62, 0x97,
	0x63, 0x16, 0xf0, 0xb7, 0x1e, 0x67, 0xbf, 0x39, 0x1d, 0x15, 0xd0, 0x9b, 0xd4, 0xb5, 0xfb, 0x36,
	0xe5, 0xac, 0xb5, 0x17, 0x4e, 0xa1, 0x0a, 0x61, 0xdb, 0x69, 0xc0, 0xe3, 0x96, 0x66, 0xc2, 0xb6,
	0x2b, 0x98, 0x38, 0x25, 0xb4, 0x31, 0x2c, 0x59, 0x3f, 0x15, 0x32, 0x0f, 0xa1, 0xa8, 0x04, 0x37,
	0xbf, 0x9f, 0x15, 0xd0, 0x05, 0xe1, 0xb5, 0x4f, 0x5d, 0xce, 0x6c, 0x8c, 0xa7, 0x60, 0xa9, 0x90,
	0x79, 0xfa, 0x58, 0x41, 0xf2, 0x14, 0x0a, 0x6f, 0x18, 0xa7, 0xb6, 0xd0, 0x8a, 0xcc, 0xb1, 0x34,
	0x5b, 0x4d, 0xe1, 0x17, 0xfa, 0xb1, 0x62, 0x66, 0xac, 0xae, 0xb4, 0xa2, 0xae, 0x17, 0x50, 0x9c,
	0xdd, 0xf1, 0xa8, 0x4d, 0x6d, 0x46, 0x9b, 0x18, 0x75, 0x5a, 0xa9, 0x7d, 0x07, 0x16, 0x0f, 0xa9,
	0x6f, 0x8b, 0xf1, 0x62, 0x89, 0x69, 0x95, 0xa1, 0x20, 0x72, 0xb0, 0x0f, 0xbc, 0xe8, 0x75, 0x88,
	0x6d, 0x31, 0x8d, 0xa1, 0xa2, 0xc2, 0x69, 0x94, 0x96, 0x79, 0x0d, 0x99, 0xb6, 0xe7, 0xa8, 0xfa,
	0xd5, 0x7e, 0xa9, 0xdf, 0x7f, 0x61, 0xb9, 0xe5, 0xf6, 0x06, 0x63, 0x9b, 0xd9, 0xea, 0x93, 0x32,
	0x0d, 0x8a, 0x76, 0x46, 0x80, 0xa2, 0xf3, 0x29, 0xcc, 0x7c, 0x0f, 0x8b, 0x16, 0x3d, 0xe7, 0x32,
	0x9d, 0xba, 0x92, 0x5b, 0x58, 0xe4, 0xb5, 0x28, 0x82, 0xd8, 0x61, 0x29, 0xf9, 0xff, 0x83, 0x71,
	0x87, 0xd3, 0xad, 0x47, 0xd4, 0xb6, 0xe7, 0x58, 0x02, 0xdf, 0x3a, 0x81, 0xf5, 0x04, 0x6d, 0x12,
	0x1d, 0xf2, 0x9d, 0x71, 0xaf, 0xc7, 0x82, 0xa0, 0x98, 0x12, 0xc6, 0xf1, 0x00, 0x63, 0x29, 0x6a,
	0x64, 0x05, 0xe0, 0xc8, 0xe3, 0x4d, 0xcf, 0xe5, 0xb4, 0xef, 0x16, 0xd3, 0x64, 0x15, 0xf4, 0xe3,
	0x81, 0x1d, 0x75, 0xab, 0x98, 0x69, 0xdc, 0x6b, 0x90, 0x17, 0xf1, 0x5a, 0x27, 0x4d, 0x72, 0x00,
	0xcb, 0x53, 0xa7, 0x93, 0x3f, 0x13, 0x1f, 0x04, 0xa1, 0x80, 0x72, 0x39, 0xd1, 0x25, 0x67, 0xf3,
	0x25, 0xe8, 0xca, 0xbc, 0x92, 0x3f, 0x22, 0xea, 0x8c, 0xc2, 0xca, 0xa5, 0x04, 0x87, 0x3c, 0xa1,
	0x0d, 0xab, 0x33, 0xda, 0x25, 0xf1, 0xe3, 0x94, 0xf0, 0x76, 0x94, 0xff, 0x9e, 0xe3, 0xc4, 0xd3,
	0x5e, 0x1d, 0xdd, 0xde, 0x1b, 0xa9, 0xbb, 0x7b, 0x23, 0x75, 0xfb, 0x60, 0x68, 0x77, 0x0f, 0x86,
	0xf6, 0xfd, 0xc1, 0xd0, 0x3e, 0x4d, 0x8c, 0xd4, 0xe7, 0x89, 0x91, 0xba, 0x9b, 0x18, 0xa9, 0x6f,
	0x13, 0x23, 0xf5, 0xae, 0xaa, 0x7c, 0xcd, 0x3e, 0x52, 0xd7, 0xb9, 0x19, 0x5f, 0xf6, 0xb7, 0x9f,
	0x6f, 0x3f, 0xab, 0xdf, 0x5c, 0x7e, 0xb8, 0xaa, 0x2b, 0x9f, 0xc2, 0x6e, 0x0e, 0xbf, 0x67, 0x3b,
	0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x93, 0xf6, 0x1c, 0x20, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftRPCClient is the client API for RaftRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftRPCClient interface {
	AppendEntries(ctx context.Context, in *AppendEntriesArgs, opts ...grpc.CallOption) (*AppendEntriesReply, error)
	RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteReply, error)
	InstallSnapshot(ctx context.Context, in *InstallSnapshotArgs, opts ...grpc.CallOption) (*InstallSnapshotReply, error)
}

type raftRPCClient struct {
	cc *grpc.ClientConn
}

func NewRaftRPCClient(cc *grpc.ClientConn) RaftRPCClient {
	return &raftRPCClient{cc}
}

func (c *raftRPCClient) AppendEntries(ctx context.Context, in *AppendEntriesArgs, opts ...grpc.CallOption) (*AppendEntriesReply, error) {
	out := new(AppendEntriesReply)
	err := c.cc.Invoke(ctx, "/raftpb.RaftRPC/AppendEntries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftRPCClient) RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteReply, error) {
	out := new(RequestVoteReply)
	err := c.cc.Invoke(ctx, "/raftpb.RaftRPC/RequestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftRPCClient) InstallSnapshot(ctx context.Context, in *InstallSnapshotArgs, opts ...grpc.CallOption) (*InstallSnapshotReply, error) {
	out := new(InstallSnapshotReply)
	err := c.cc.Invoke(ctx, "/raftpb.RaftRPC/InstallSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftRPCServer is the server API for RaftRPC service.
type RaftRPCServer interface {
	AppendEntries(context.Context, *AppendEntriesArgs) (*AppendEntriesReply, error)
	RequestVote(context.Context, *RequestVoteArgs) (*RequestVoteReply, error)
	InstallSnapshot(context.Context, *InstallSnapshotArgs) (*InstallSnapshotReply, error)
}

// UnimplementedRaftRPCServer can be embedded to have forward compatible implementations.
type UnimplementedRaftRPCServer struct {
}

func (*UnimplementedRaftRPCServer) AppendEntries(ctx context.Context, req *AppendEntriesArgs) (*AppendEntriesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}
func (*UnimplementedRaftRPCServer) RequestVote(ctx context.Context, req *RequestVoteArgs) (*RequestVoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (*UnimplementedRaftRPCServer) InstallSnapshot(ctx context.Context, req *InstallSnapshotArgs) (*InstallSnapshotReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}

func RegisterRaftRPCServer(s *grpc.Server, srv RaftRPCServer) {
	s.RegisterService(&_RaftRPC_serviceDesc, srv)
}

func _RaftRPC_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftRPCServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftpb.RaftRPC/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftRPCServer).AppendEntries(ctx, req.(*AppendEntriesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftRPC_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftRPCServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftpb.RaftRPC/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftRPCServer).RequestVote(ctx, req.(*RequestVoteArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftRPC_InstallSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallSnapshotArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftRPCServer).InstallSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftpb.RaftRPC/InstallSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftRPCServer).InstallSnapshot(ctx, req.(*InstallSnapshotArgs))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "raftpb.RaftRPC",
	HandlerType: (*RaftRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntries",
			Handler:    _RaftRPC_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _RaftRPC_RequestVote_Handler,
		},
		{
			MethodName: "InstallSnapshot",
			Handler:    _RaftRPC_InstallSnapshot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "raft/raftpb/raft.proto",
}

func (m *Args) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Args) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Args) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntriesArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntriesArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevLogTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.PrevLogTerm))
		i--
		dAtA[i] = 0x38
	}
	if m.PrevLogIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.PrevLogIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.LeaderCommit != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.LeaderCommit))
		i--
		dAtA[i] = 0x20
	}
	if m.CommitTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.CommitTerm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntriesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntriesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.XTerm))
		i--
		dAtA[i] = 0x28
	}
	if m.XLen != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.XLen))
		i--
		dAtA[i] = 0x20
	}
	if m.XIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.XIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InstallSnapshotArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallSnapshotArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallSnapshotReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallSnapshotReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestVoteArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVoteArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastLogTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.LastLogTerm))
		i--
		dAtA[i] = 0x20
	}
	if m.LastLogIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.LastLogIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.CandidateID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.CandidateID))
		i--
		dAtA[i] = 0x10
	}
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestVoteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVoteReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VoteGranted {
		i--
		if m.VoteGranted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HardState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commit != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x18
	}
	if m.VotedFor != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.VotedFor))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludedTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.IncludedTerm))
		i--
		dAtA[i] = 0x18
	}
	if m.IncludedIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.IncludedIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Log != nil {
		{
			size, err := m.Log.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HardState != nil {
		{
			size, err := m.HardState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Args) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Leader != 0 {
		n += 1 + sovRaft(uint64(m.Leader))
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *AppendEntriesArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.CommitTerm != 0 {
		n += 1 + sovRaft(uint64(m.CommitTerm))
	}
	if m.LeaderCommit != 0 {
		n += 1 + sovRaft(uint64(m.LeaderCommit))
	}
	if m.PrevLogIndex != 0 {
		n += 1 + sovRaft(uint64(m.PrevLogIndex))
	}
	if m.PrevLogTerm != 0 {
		n += 1 + sovRaft(uint64(m.PrevLogTerm))
	}
	return n
}

func (m *AppendEntriesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	if m.XIndex != 0 {
		n += 1 + sovRaft(uint64(m.XIndex))
	}
	if m.XLen != 0 {
		n += 1 + sovRaft(uint64(m.XLen))
	}
	if m.XTerm != 0 {
		n += 1 + sovRaft(uint64(m.XTerm))
	}
	return n
}

func (m *InstallSnapshotArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *InstallSnapshotReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	return n
}

func (m *RequestVoteArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.CandidateID != 0 {
		n += 1 + sovRaft(uint64(m.CandidateID))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovRaft(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovRaft(uint64(m.LastLogTerm))
	}
	return n
}

func (m *RequestVoteReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.VoteGranted {
		n += 2
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *SnapshotMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	return n
}

func (m *HardState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.VotedFor != 0 {
		n += 1 + sovRaft(uint64(m.VotedFor))
	}
	if m.Commit != 0 {
		n += 1 + sovRaft(uint64(m.Commit))
	}
	return n
}

func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.IncludedIndex != 0 {
		n += 1 + sovRaft(uint64(m.IncludedIndex))
	}
	if m.IncludedTerm != 0 {
		n += 1 + sovRaft(uint64(m.IncludedTerm))
	}
	return n
}

func (m *RaftState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HardState != nil {
		l = m.HardState.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Log != nil {
		l = m.Log.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func sovRaft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Args) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &Args{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTerm", wireType)
			}
			m.CommitTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderCommit", wireType)
			}
			m.LeaderCommit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderCommit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogIndex", wireType)
			}
			m.PrevLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogTerm", wireType)
			}
			m.PrevLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppendEntriesStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XIndex", wireType)
			}
			m.XIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XLen", wireType)
			}
			m.XLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XTerm", wireType)
			}
			m.XTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &Args{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &Args{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidateID", wireType)
			}
			m.CandidateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CandidateID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteGranted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VoteGranted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &SnapshotMetaData{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedFor", wireType)
			}
			m.VotedFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotedFor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludedIndex", wireType)
			}
			m.IncludedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncludedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludedTerm", wireType)
			}
			m.IncludedTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncludedTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HardState == nil {
				m.HardState = &HardState{}
			}
			if err := m.HardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Log == nil {
				m.Log = &Log{}
			}
			if err := m.Log.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft = fmt.Errorf("proto: unexpected end of group")
)
